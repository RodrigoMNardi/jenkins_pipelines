properties([
    parameters([
        string(name: 'GIT_REF', defaultValue: 'feature/jenkins', description: 'Branch, tag or commit SHA to build')
    ])
])

pipeline {
    agent none

    environment {
        POSTGRES_USER = 'postgres'
        POSTGRES_PASSWORD = 'postgres'
        POSTGRES_DB = 'postgres'
        POSTGRES_HOST = '172.17.0.1'
        DATABASE_URL = 'postgres://postgres:postgres@172.17.0.1:5432'
    }

    stages {
        stage("Ruby Pipeline") {
            matrix {
                axes {
                    axis {
                        name 'RUBY_VERSION'
                        values '3.2', '3.4', '4.0.1'
                    }
                }
                agent {
                    docker {
                        image "ruby:${RUBY_VERSION}"
                    }
                }
                environment {
                    POSTGRES_PORT = "${['3.2':'5433','3.4':'5434','4.0.1':'5435'][RUBY_VERSION]}"
                    POSTGRES_CONTAINER = "jenkins-postgres-${RUBY_VERSION.replace('.', '-')}-${env.BUILD_ID ?: env.BUILD_NUMBER}-${UUID.randomUUID().toString()}"
                    POSTGRES_VOLUME = "jenkins-pgdata-${RUBY_VERSION.replace('.', '-')}-${env.BUILD_ID ?: env.BUILD_NUMBER}"
                    DATABASE_URL = "postgres://postgres:postgres@172.17.0.1:${['3.2':'5433','3.4':'5434','4.0.1':'5435'][RUBY_VERSION]}"
                }
                stages {
                    stage("Start Postgres") {
                        steps {
                            echo "RUBY_VERSION: ${RUBY_VERSION} | POSTGRES_PORT: ${env.POSTGRES_PORT} | POSTGRES_CONTAINER: ${env.POSTGRES_CONTAINER} | POSTGRES_VOLUME: ${env.POSTGRES_VOLUME}"
                            sh '''
                              if docker ps -a --format '{{.Names}}' | grep -wq "$POSTGRES_CONTAINER"; then
                                docker stop $POSTGRES_CONTAINER || true
                                docker rm -f $POSTGRES_CONTAINER || true
                                sleep 2
                              fi
                              if docker volume ls -q | grep -wq "$POSTGRES_VOLUME"; then
                                docker volume rm -f $POSTGRES_VOLUME || true
                              fi
                              docker run --name $POSTGRES_CONTAINER -p $POSTGRES_PORT:5432 -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=postgres -v $POSTGRES_VOLUME:/var/lib/postgresql/data -d postgres:15
                              for i in {1..60}; do
                                docker exec $POSTGRES_CONTAINER pg_isready -U postgres && break
                                sleep 1
                              done
                            '''
                        }
                    }
                    stage('Checkout') {
                        steps {
                            deleteDir()
                            checkout([
                                $class: 'GitSCM',
                                branches: [[name: params.GIT_REF]],
                                userRemoteConfigs: [[url: 'https://github.com/RodrigoMNardi/netdef-ci-github-app.git']]
                            ])
                        }
                    }
                    stage('01 - Install bundler') {
                        steps {
                            sh 'gem install bundler -v 2.7.1'
                        }
                    }
                    stage('02 - Install gems') {
                        steps {
                            sh 'bundle install'
                        }
                    }
                    stage("03 - Create DB") {
                        environment {
                            RACK_ENV = 'test'
                            POSTGRES_PORT = "${['3.2':'5433','3.4':'5434','4.0.1':'5435'][RUBY_VERSION]}"
                            POSTGRES_CONTAINER = "jenkins-postgres-${RUBY_VERSION.replace('.', '-')}-${env.BUILD_ID ?: env.BUILD_NUMBER}-${UUID.randomUUID().toString()}"
                            DATABASE_URL = "postgres://postgres:postgres@172.17.0.1:${['3.2':'5433','3.4':'5434','4.0.1':'5435'][RUBY_VERSION]}"
                        }
                        steps {
                            sh '''
                              cp database_template.yml config/database.yml
                              sed -i "s/localhost/172.17.0.1/g" config/database.yml
                              sed -i "s/timeout: 5000/port: $POSTGRES_PORT/g" config/database.yml
                              cp db/schema.rb db/schema.rb.bak
                              bundle exec rake db:migrate:reset
                              if ! cmp db/schema.rb db/schema.rb.bak >/dev/null 2>&1; then
                                echo 'Your db/schema.rb differs from the schema generated by the migrations.'
                                echo 'Use "DATABASE=migrations bundle exec rake db:migrate:reset" to regenerate the schema.'
                                diff db/schema.rb db/schema.rb.bak
                                exit 1
                              fi
                            '''
                        }
                    }
                    stage("04 - Unit Tests") {
                        environment {
                            DATABASE_URL = "${env.DATABASE_URL}"
                        }
                        steps {
                            sh 'cp config_template.yml config.yml || true'
                            sh 'cat config/database.yml'
                            sh 'bundle exec rspec'
                        }
                    }
                }
                post {
                    always {
                        script {
                            def buildId = env.BUILD_ID ?: env.BUILD_NUMBER
                            def prefix = "jenkins-postgres-${RUBY_VERSION.toString().replace('.', '-')}-${buildId}-"
                            def volPrefix = "jenkins-pgdata-${RUBY_VERSION.toString().replace('.', '-')}-${buildId}-"
                            def cleanupCmd = """
                                echo "[CLEANUP] Removing containers with prefix: ${prefix}"
                                for c in \$(docker ps -a --format '{{.Names}}' | grep "^${prefix}"); do
                                  docker stop \$c || true
                                  docker rm -f \$c || true
                                  sleep 2
                                done
                                echo "[CLEANUP] Removing volumes with prefix: ${volPrefix}"
                                for v in \$(docker volume ls -q | grep "^${volPrefix}"); do
                                  docker volume rm -f \$v || true
                                done
                            """
                            sh cleanupCmd
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline done'
        }
        success {
            echo 'SUCCESS!'
        }
        failure {
            echo '‚ùå FAILURE!'
        }
    }
}
